<?php
require __DIR__ . '/../../vendor/autoload.php';

use PhpMqtt\Client\MqttClient;
use PhpMqtt\Client\ConnectionSettings;
use Medoo\Medoo;
use Predis\Client as RedisClient;

// T·∫£i c·∫•u h√¨nh t·ª´ .env
$envPath = __DIR__ . '/../../.env';
if (!file_exists($envPath)) {
    http_response_code(500);
    die(json_encode(['error' => 'FATAL ERROR: File .env kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y.']));
}
$env = parse_ini_file($envPath);
$publicBaseUrl = rtrim($env['APP_URL'] ?? 'http://localhost', '/');
$facesUploadPath = __DIR__ . '/../../public/uploads/faces/';
$photosUploadPath = __DIR__ . '/../../public/uploads/photos/';
$webhookSecret = $env['WEBHOOK_SECRET'] ?? 'your-secret-key'; // Th√™m secret key t·ª´ .env

// Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c
foreach ([$facesUploadPath, $photosUploadPath] as $path) {
    if (!is_dir($path)) {
        if (!mkdir($path, 0775, true)) {
            http_response_code(500);
            die(json_encode(['error' => "FATAL ERROR: Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c {$path}."]));
        }
        error_log("‚úÖ [INIT] ƒê√£ t·∫°o th∆∞ m·ª•c: $path");
    }
    if (!is_writable($path)) {
        http_response_code(500);
        die(json_encode(['error' => "FATAL ERROR: Th∆∞ m·ª•c {$path} kh√¥ng c√≥ quy·ªÅn ghi."]));
    }
}

// K·∫øt n·ªëi Database
try {
    $database = new Medoo([
        'database_type' => $env['DB_CONNECTION'] ?? 'mysql',
        'database_name' => $env['DB_DATABASE'] ?? 'eclo-camera',
        'server'        => $env['DB_HOST'] ?? 'localhost',
        'username'      => $env['DB_USERNAME'] ?? 'root',
        'password'      => $env['DB_PASSWORD'] ?? '',
        'charset'       => $env['DB_CHARSET'] ?? 'utf8mb4',
        'error'         => PDO::ERRMODE_EXCEPTION,
    ]);
} catch (PDOException $e) {
    http_response_code(500);
    die(json_encode(['error' => "FATAL ERROR: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn database: " . $e->getMessage()]));
}

// K·∫øt n·ªëi Redis
try {
    $redis = new RedisClient([
        'scheme' => 'tcp',
        'host'   => $env['REDIS_HOST'] ?? '127.0.0.1',
        'port'   => (int)($env['REDIS_PORT'] ?? 6379),
    ]);
    $redis->ping();
} catch (Exception $e) {
    http_response_code(500);
    die(json_encode(['error' => "FATAL ERROR: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Redis: " . $e->getMessage()]));
}

/**
 * G·ª≠i m·ªôt tin nh·∫Øn ƒë·∫øn MQTT Broker.
 */
function publishMqttMessage(array $env, string $topic, array $payload): bool
{
    $mqttServer = $env['MQTT_HOST'] ?? 'mqtt.ellm.io';
    $mqttPort = (int)($env['MQTT_PORT_TCP'] ?? 1883);
    $mqttUsername = $env['MQTT_USERNAME'] ?? 'eclo';
    $mqttPassword = $env['MQTT_PASSWORD'] ?? 'Eclo@123';
    $mqttClientId = 'backend-publisher-' . uniqid();

    try {
        $mqtt = new MqttClient($mqttServer, $mqttPort, $mqttClientId);
        $connectionSettings = (new ConnectionSettings)
            ->setUsername($mqttUsername)
            ->setPassword($mqttPassword)
            ->setConnectTimeout(5);
        $mqtt->connect($connectionSettings, true);
        $mqtt->publish($topic, json_encode($payload, JSON_UNESCAPED_UNICODE), 0);
        $mqtt->disconnect();
        error_log("‚úÖ MQTT Publish Success to topic [{$topic}]");
        return true;
    } catch (Exception $e) {
        error_log("‚ùå MQTT Publish Error: " . $e->getMessage());
        return false;
    }
}

/**
 * L∆∞u h√¨nh ·∫£nh t·ª´ chu·ªói base64 v√† tr·∫£ v·ªÅ m·∫£ng ƒë∆∞·ªùng d·∫´n.
 */
function save_image_from_base64(?string $picBase64, string $facesUploadPath, string $photosUploadPath, string $prefix, string $uniqueId): ?array
{
    if (empty($picBase64)) {
        error_log("‚ö†Ô∏è [save_image] Chu·ªói base64 r·ªóng.");
        return null;
    }

    error_log("üì∑ [save_image] Chu·ªói base64 ƒë·∫ßu v√†o (50 k√Ω t·ª± ƒë·∫ßu): " . substr($picBase64, 0, 50));

    if (!preg_match('/^data:image\/(jpeg|jpg|png);base64,/', $picBase64, $matches)) {
        error_log("‚ö†Ô∏è [save_image] Chu·ªói base64 kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (kh√¥ng ph·∫£i jpeg/jpg/png).");
        return null;
    }

    if (!is_writable($facesUploadPath) || !is_writable($photosUploadPath)) {
        error_log("‚ö†Ô∏è [save_image] M·ªôt ho·∫∑c c·∫£ hai th∆∞ m·ª•c kh√¥ng th·ªÉ ghi: $facesUploadPath, $photosUploadPath");
        return null;
    }

    try {
        list(, $data) = explode(',', $picBase64);
        $imageData = base64_decode($data);
        if ($imageData === false) {
            error_log("‚ö†Ô∏è [save_image] L·ªói gi·∫£i m√£ base64: Chu·ªói kh√¥ng h·ª£p l·ªá.");
            return null;
        }

        $imageExtension = ($matches[1] === 'jpeg') ? 'jpg' : $matches[1];
        $imageName = $prefix . str_replace('.', '_', $uniqueId) . '_' . time() . '.' . $imageExtension;
        
        $facesFilePath = rtrim($facesUploadPath, '/') . '/' . $imageName;
        $photosFilePath = rtrim($photosUploadPath, '/') . '/' . $imageName;

        error_log("üìÅ [save_image] ƒêang l∆∞u ·∫£nh v√†o: $facesFilePath");

        if (file_put_contents($facesFilePath, $imageData) === false) {
            error_log("‚ö†Ô∏è [save_image] Kh√¥ng th·ªÉ ghi file v√†o: $facesFilePath. L·ªói: " . error_get_last()['message']);
            return null;
        }
        if (!file_exists($facesFilePath)) {
            error_log("‚ö†Ô∏è [save_image] File kh√¥ng t·ªìn t·∫°i sau khi ghi: $facesFilePath");
            return null;
        }
        chmod($facesFilePath, 0644);

        error_log("üìÅ [save_image] ƒêang sao ch√©p ·∫£nh sang: $photosFilePath");

        if (!copy($facesFilePath, $photosFilePath)) {
            error_log("‚ö†Ô∏è [save_image] Kh√¥ng th·ªÉ sao ch√©p file sang: $photosFilePath. L·ªói: " . error_get_last()['message']);
            unlink($facesFilePath);
            return null;
        }
        if (!file_exists($photosFilePath)) {
            error_log("‚ö†Ô∏è [save_image] File kh√¥ng t·ªìn t·∫°i sau khi sao ch√©p: $photosFilePath");
            unlink($facesFilePath);
            return null;
        }
        chmod($photosFilePath, 0644);
        
        error_log("‚úÖ [save_image] ƒê√£ l∆∞u v√† sao ch√©p ·∫£nh th√†nh c√¥ng: $imageName");

        return [
            'faces_path' => 'uploads/faces/' . $imageName,
            'photos_path' => 'uploads/photos/' . $imageName
        ];
    } catch (Exception $e) {
        error_log("‚ö†Ô∏è [save_image] L·ªói ngo·∫°i l·ªá khi x·ª≠ l√Ω ·∫£nh: " . $e->getMessage());
        return null;
    }
}

// C·∫•u h√¨nh HTTP response
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *'); 
header('Access-Control-Allow-Methods: POST');

// X√°c th·ª±c webhook
if (!isset($_SERVER['HTTP_X_WEBHOOK_SECRET']) || $_SERVER['HTTP_X_WEBHOOK_SECRET'] !== $webhookSecret) {
    http_response_code(403);
    echo json_encode(['error' => 'Unauthorized']);
    exit;
}

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    echo json_encode(['error' => 'Method not allowed']);
    exit;
}

// Nh·∫≠n d·ªØ li·ªáu t·ª´ webhook
$input = file_get_contents('php://input');
$payload = json_decode($input, true);

if (!$payload || !isset($payload['info']) || !isset($payload['topic'])) {
    error_log("‚ùå [WEBHOOK] Payload kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu info/topic: " . $input);
    http_response_code(400);
    echo json_encode(['error' => 'Invalid payload']);
    exit;
}

$info = $payload['info'];
$topic = $payload['topic'];
$eventType = basename($topic);
error_log("üì∏ [WEBHOOK] Payload cho topic [$topic]: " . json_encode($payload, JSON_UNESCAPED_UNICODE));

// X·ª≠ l√Ω logic d·ª±a tr√™n event type
if ($eventType === 'Rec') {
    $imagePaths = save_image_from_base64($info['pic'] ?? null, $facesUploadPath, $photosUploadPath, 'rec_', $info['personId'] ?? uniqid());

    $recData = [
        'event_type'  => 'Rec',
        'person_name' => $info['personName'] ?? ($info['persionName'] ?? 'N/A'),
        'person_id'   => $info['personId'] ?? 'N/A',
        'similarity'  => (float)($info['similarity1'] ?? 0),
        'record_id'   => (int)($info['RecordID'] ?? 0),
        'event_time'  => $info['time'] ?? date('Y-m-d H:i:s'),
        'image_path'  => $imagePaths['faces_path'] ?? null,
    ];
    $database->insert('mqtt_messages', $recData);
    error_log("‚úÖ [WEBHOOK] ƒê√£ ghi nh·∫≠n s·ª± ki·ªán Rec cho: " . $recData['person_name']);
    echo json_encode(['status' => 'success', 'event' => 'Rec']);
}

elseif ($eventType === 'Snap') {
    $picBase64 = $info['pic'] ?? null;

    $snapData = [
        'event_type'  => 'Snap',
        'person_name' => 'Ng∆∞·ªùi l·∫°',
        'event_time'  => $info['time'] ?? date('Y-m-d H:i:s'),
        'image_path'  => null,
    ];

    if (!$picBase64) {
        error_log("‚ùå [WEBHOOK] Payload thi·∫øu pic base64.");
        $database->insert('mqtt_messages', $snapData);
        echo json_encode(['status' => 'success', 'event' => 'Snap', 'message' => 'No image']);
        exit;
    }

    $imageHash = md5($picBase64);
    $redisKey = 'snap_cooldown:' . $imageHash;
    $lockKey = 'snap_lock:' . $imageHash;
    $lockAcquired = $redis->set($lockKey, 1, 'NX', 'EX', 10);

    if (!$lockAcquired) {
        error_log("‚ÑπÔ∏è [WEBHOOK] B·ªè qua v√¨ tin nh·∫Øn ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi lu·ªìng kh√°c.");
        $database->insert('mqtt_messages', $snapData);
        echo json_encode(['status' => 'success', 'event' => 'Snap', 'message' => 'Locked']);
        exit;
    }

    try {
        if ($redis->exists($redisKey)) {
            error_log("‚ÑπÔ∏è [WEBHOOK] B·ªè qua v√¨ g∆∞∆°ng m·∫∑t n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω g·∫ßn ƒë√¢y.");
            $database->insert('mqtt_messages', $snapData);
            echo json_encode(['status' => 'success', 'event' => 'Snap', 'message' => 'Cooldown']);
            exit;
        }

        $newSn = uniqid('NV_');
        $imagePaths = save_image_from_base64($picBase64, $facesUploadPath, $photosUploadPath, 'snap_', $newSn);

        if ($imagePaths === null) {
            error_log("‚ö†Ô∏è [WEBHOOK] Kh√¥ng th·ªÉ l∆∞u ·∫£nh. D·ª´ng qu√° tr√¨nh t·ª± ƒë·ªông ƒëƒÉng k√Ω.");
            $database->insert('mqtt_messages', $snapData);
            echo json_encode(['status' => 'success', 'event' => 'Snap', 'message' => 'Image save failed']);
            exit;
        }

        $snapData['person_name'] = 'Ng∆∞·ªùi l·∫° (Auto-Reg)';
        $snapData['image_path'] = $imagePaths['faces_path'];
        $database->insert('mqtt_messages', $snapData);

        $newPersonName = 'Ng∆∞·ªùi l·∫° ' . date('d/m H:i');
        try {
            $database->insert("employee", [
                'sn' => $newSn,
                'person_name' => $newPersonName,
                'registration_photo' => $imagePaths['photos_path'],
            ]);

            $publicImageUrl = $publicBaseUrl . '/' . $imagePaths['photos_path'];
            $mqttPayload = [
                "messageId" => uniqid(),
                "operator" => "EditPerson",
                "info" => [ "customId" => $newSn, "name" => $newPersonName, "personType" => 0, "picURI" => $publicImageUrl ]
            ];
            publishMqttMessage($env, 'mqtt/face/1018656', $mqttPayload);

            $redis->setex($redisKey, 300, 1);
            echo json_encode(['status' => 'success', 'event' => 'Snap', 'message' => 'Processed']);
        } catch (Exception $e) {
            if (file_exists($facesUploadPath . basename($imagePaths['faces_path']))) {
                unlink($facesUploadPath . basename($imagePaths['faces_path']));
            }
            if (file_exists($photosUploadPath . basename($imagePaths['photos_path']))) {
                unlink($photosUploadPath . basename($imagePaths['photos_path']));
            }
            error_log("‚ùå [WEBHOOK] L·ªói DB khi t·ª± ƒë·ªông th√™m nh√¢n vi√™n: " . $e->getMessage());
            echo json_encode(['status' => 'error', 'event' => 'Snap', 'message' => 'DB error']);
        }
    } finally {
        $redis->del($lockKey);
    }
} else {
    error_log("‚ùå [WEBHOOK] Event type kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: $eventType");
    echo json_encode(['status' => 'error', 'message' => 'Unsupported event type']);
}